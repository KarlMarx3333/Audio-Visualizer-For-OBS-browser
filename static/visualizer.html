<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>ObsVizHost Visualizer</title>
  <link rel="stylesheet" href="/static/css/app.css"/>
  <style>
    body { overflow: hidden; }
    html.embed, body.embed { background: transparent !important; }
    body.embed #wrap, body.embed #stage { background: transparent !important; }
    body.embed #canvas { background: transparent !important; }
    #wrap { position: fixed; inset: 0; display: grid; grid-template-rows: auto 1fr; background: transparent; }
    #topbar { padding: 10px 12px; background: rgba(18,24,36,0.85); border-bottom: 1px solid rgba(255,255,255,0.06); }
    #topbar.hidden { display: none; }
    #stage { display: flex; align-items: center; justify-content: center; background: transparent; width: 100%; height: 100%; }
    #canvas { display: block; background: transparent; }
    #meta { font-size: 12px; color: #9fb0c8; display:flex; gap:12px; align-items:center; flex-wrap:wrap;}
    #meta b { color: #e6eefc; }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="topbar">
      <div class="row" style="align-items:flex-end;">
        <div class="col" style="min-width:220px">
          <label>Visualizer</label>
          <select id="vizSel"></select>
        </div>
        <div class="col" style="min-width:220px">
          <label>Gain (tray)</label>
          <input id="gain" type="range" min="0.2" max="4.0" step="0.01" value="1.0" disabled/>
        </div>
        <div class="col" style="min-width:220px">
          <label>Smoothing (tray)</label>
          <input id="vsmooth" type="range" min="0" max="0.95" step="0.01" value="0.55" disabled/>
        </div>
        <div class="col" style="min-width:220px">
          <label>&nbsp;</label>
          <button id="fit">Fit</button>
        </div>
      </div>
      <div style="height:10px"></div>
      <div id="meta"></div>
    </div>
    <div id="stage">
      <canvas id="canvas"></canvas>
    </div>
  </div>

<script type="module">
import { connectAudioWS } from "/static/js/ws_client.js";
import { registry, createVisualizer } from "/static/js/visualizers/registry.js";

const qs = new URLSearchParams(location.search);
const embed = qs.get("embed") === "1";
const debug = qs.get("debug") === "1";

const topbar = document.getElementById("topbar");
if(embed){
  topbar.classList.add("hidden");
  document.documentElement.classList.add("embed");
  document.body.classList.add("embed");
}

let canvas = document.getElementById("canvas");
const wrap = document.getElementById("wrap");
const vizSel = document.getElementById("vizSel");
const gainEl = document.getElementById("gain");
const vsmoothEl = document.getElementById("vsmooth");
const meta = document.getElementById("meta");

function currentVizFromPath(){
  const parts = location.pathname.split("/");
  const name = parts[parts.length-1] || "spectrum";
  return name;
}

const fixedViz = qs.get("viz") || (location.pathname.startsWith("/v/") ? currentVizFromPath() : null);
const followServer = fixedViz == null;

function resize(){
  const dpr = window.devicePixelRatio || 1;
  const wrapRect = wrap.getBoundingClientRect();
  let availW = wrapRect.width;
  let availH = wrapRect.height;
  if(!embed){
    const topRect = topbar.getBoundingClientRect();
    availH = Math.max(0, availH - topRect.height);
  }
  const scale = 0.8;
  const cssW = Math.max(2, Math.floor(availW * scale));
  const cssH = Math.max(2, Math.floor(availH * scale));
  canvas.style.width = `${cssW}px`;
  canvas.style.height = `${cssH}px`;
  canvas.width = Math.max(2, Math.floor(cssW * dpr));
  canvas.height = Math.max(2, Math.floor(cssH * dpr));
  if(viz && viz.onResize) viz.onResize(canvas.width, canvas.height, dpr);
}
window.addEventListener("resize", resize);
document.getElementById("fit").addEventListener("click", resize);

registry.ensureLoaded();

for(const v of registry.list()){
  vizSel.appendChild(new Option(v.name + " ("+v.renderer+")", v.id));
}

let vizName = fixedViz || "spectrum";
if(!registry.get(vizName)) vizName = "spectrum";

let currentRenderer = (registry.get(vizName)?.renderer ?? "2d");

function replaceCanvas(){
  const old = canvas;
  const nu = old.cloneNode(false);
  old.replaceWith(nu);
  canvas = nu;
}

let viz = null;
let latestFrame = null;
let lastState = { samplerate: 48000, fft_size: 2048 };
let vizError = null;
const mutationLogged = new Set();
const debugBadge = debug ? document.createElement("div") : null;
if(debugBadge){
  debugBadge.style.cssText = "position:fixed;right:8px;bottom:8px;z-index:9999;background:rgba(200,40,40,0.9);color:#fff;padding:4px 6px;border-radius:4px;font:11px/1.2 sans-serif;pointer-events:none;display:none;";
  document.body.appendChild(debugBadge);
}

function errorText(err){
  if(!err) return "";
  if(typeof err === "string") return err;
  if(err.message) return err.message;
  return String(err);
}

function updateErrorBadge(){
  if(!debugBadge) return;
  if(!vizError){
    debugBadge.style.display = "none";
    debugBadge.removeAttribute("title");
    return;
  }
  debugBadge.style.display = "block";
  debugBadge.textContent = "viz error";
  debugBadge.title = errorText(vizError);
}

function recordVizError(err){
  vizError = err;
  updateErrorBadge();
}

function clearVizError(){
  vizError = null;
  updateErrorBadge();
}

window.addEventListener("error", (e)=>{
  const err = e.error || e.message || e;
  console.error(err);
  recordVizError(err);
});

window.addEventListener("unhandledrejection", (e)=>{
  console.error(e.reason);
  recordVizError(e.reason);
});

function setViz(name){
  let destroyError = null;
  let destroyFailed = false;
  if(viz && viz.destroy){
    try{
      viz.destroy();
    }catch(err){
      destroyError = err;
      destroyFailed = true;
      console.error("destroy failed", err);
      recordVizError(err);
    }
  }

  viz = null;
  vizName = name;
  if(debug) mutationLogged.clear();

  const nextRenderer = (registry.get(name)?.renderer ?? "2d");
  if(destroyFailed || nextRenderer !== currentRenderer || (currentRenderer === "webgl" && nextRenderer === "webgl")){
    replaceCanvas();
  }

  const tryCreate = (id)=>{
    try{
      viz = createVisualizer(id, canvas);
      vizName = id;
      return null;
    }catch(err){
      console.error(err);
      return err;
    }
  };

  let err = tryCreate(name);
  if(err){
    recordVizError(err);
    const fallback = name !== "spectrum" && registry.get("spectrum") ? "spectrum" : null;
    if(fallback){
      replaceCanvas();
      err = tryCreate(fallback);
      if(err){
        recordVizError(err);
        viz = null;
      }else if(vizSel.value !== fallback){
        vizSel.value = fallback;
      }
    }else{
      viz = null;
    }
  }else if(!destroyError){
    clearVizError();
  }

  if(!viz){
    if(!embed){
      meta.innerHTML = `Visualizer error: <b>${errorText(vizError)}</b>`;
    }
    return;
  }

  currentRenderer = (registry.get(vizName)?.renderer ?? "2d");

  const allowHistory = location.pathname.startsWith("/v/");
  if(!embed && allowHistory){
    history.replaceState({}, "", `/v/${vizName}${location.search}`);
  }
  resize();
}

async function initViz(){
  if(followServer){
    try{
      const st = await (await fetch("/api/state")).json();
      if(st.visualizer_name && registry.get(st.visualizer_name)){
        vizName = st.visualizer_name;
      }
    }catch(e){}
  }
  vizSel.value = vizName;
  setViz(vizName);
}

initViz();

vizSel.addEventListener("change", async ()=>{
  const next = vizSel.value;
  setViz(next);
  if(followServer && !embed){
    try{
      await fetch("/api/visualizer", {
        method:"POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({visualizer: next}),
      });
    }catch(e){}
  }
});

async function pollState(){
  try{
    const st = await (await fetch("/api/state")).json();
    lastState = { samplerate: st.samplerate || 48000, fft_size: st.fft_size || 2048 };
    if(followServer && st.visualizer_name && st.visualizer_name !== vizName){
      if(registry.get(st.visualizer_name)){
        vizSel.value = st.visualizer_name;
        setViz(st.visualizer_name);
      }
    }
    if(typeof st.gain === "number"){
      gainEl.value = String(st.gain);
    }
    if(typeof st.visual_smoothing === "number"){
      vsmoothEl.value = String(st.visual_smoothing);
    }
    const rms = (st.metrics?.rms||[]).map(x=>x.toFixed(4)).join(",");
    const peak = (st.metrics?.peak||[]).map(x=>x.toFixed(4)).join(",");
    const err = vizError ? ` | visualizer <b style="color:#ff6b6b">error</b>` : "";
    meta.innerHTML = `Status <b>${st.status}</b> | ws <b>${st.ws_clients}</b> | rms <b>${rms}</b> | peak <b>${peak}</b> | fft <b>${st.fft_size}</b> | gain <b>${Number(gainEl.value).toFixed(2)}x</b> | smooth <b>${Number(vsmoothEl.value).toFixed(2)}</b>${err}`;
  }catch(e){}
}
setInterval(pollState, 800);
pollState();

connectAudioWS({
  url: (location.protocol === "https:" ? "wss://" : "ws://") + location.host + "/ws/audio",
  onFrame: (frame)=>{ latestFrame = frame; },
});

let lastSpectrum = null;
let lastWave = null;
let lastWaveLR = null;

function smoothArray(prev, cur, alpha){
  if(!prev || prev.length !== cur.length){
    return cur.slice ? cur.slice() : new Float32Array(cur);
  }
  const out = prev;
  const a = alpha;
  const b = 1 - a;
  for(let i=0;i<cur.length;i++){
    out[i] = a*out[i] + b*cur[i];
  }
  return out;
}

function checksumArray(arr){
  if(!arr || !arr.length) return null;
  const len = arr.length;
  const stride = Math.max(1, Math.floor(len / 64));
  let sum = 0;
  let sumAbs = 0;
  let max = 0;
  for(let i=0;i<len;i+=stride){
    const v = arr[i];
    sum += v;
    const av = Math.abs(v);
    sumAbs += av;
    if(av > max) max = av;
  }
  const q = (x)=> Math.round(x * 1e6);
  return [len, q(sum), q(sumAbs), q(max)];
}

function sameChecksum(a, b){
  if(a === b) return true;
  if(!a || !b) return false;
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

function reportMutation(which){
  const key = `${vizName}:${which}`;
  if(mutationLogged.has(key)) return;
  mutationLogged.add(key);
  const label = registry.get(vizName)?.name || vizName;
  const msg = `[VizMutation] ${label} (${vizName}) modified input ${which}`;
  console.error(msg);
  recordVizError(msg);
}

function animate(){
  requestAnimationFrame(animate);
  if(!viz || !latestFrame) return;

  const gain = Number(gainEl.value);
  const alpha = Number(vsmoothEl.value);

  const spectrum = latestFrame.spectrum;
  const waveLR = latestFrame.timeDomain;
  const ch = latestFrame.channels;

  let monoWave;
  if(ch === 1){
    monoWave = waveLR;
  }else{
    const n = Math.floor(waveLR.length / 2);
    if(!viz._mono || viz._mono.length !== n) viz._mono = new Float32Array(n);
    const m = viz._mono;
    for(let i=0;i<n;i++){
      m[i] = 0.5*(waveLR[2*i] + waveLR[2*i+1]);
    }
    monoWave = m;
  }

  lastSpectrum = smoothArray(lastSpectrum, spectrum, alpha);
  lastWave = smoothArray(lastWave, monoWave, alpha);
  if(ch === 2){
    lastWaveLR = smoothArray(lastWaveLR, waveLR, alpha);
  }else{
    lastWaveLR = null;
  }

  const frame = {
    frameId: latestFrame.frameId,
    ts: latestFrame.ts,
    channels: ch,
    rms: latestFrame.rms,
    peak: latestFrame.peak,
    corr: latestFrame.corr,
    overlay: embed,
    waveLR: lastWaveLR,
    spectrum: lastSpectrum,
    wave: lastWave,
    gain,
    samplerate: lastState.samplerate,
    fftSize: lastState.fft_size,
  };

  if(debug){
    const cSpec0 = checksumArray(lastSpectrum);
    const cWave0 = checksumArray(lastWave);
    const cLR0 = checksumArray(lastWaveLR);

    viz.onFrame(frame);

    const cSpec1 = checksumArray(lastSpectrum);
    const cWave1 = checksumArray(lastWave);
    const cLR1 = checksumArray(lastWaveLR);

    if(!sameChecksum(cSpec0, cSpec1)) reportMutation("spectrum");
    if(!sameChecksum(cWave0, cWave1)) reportMutation("wave");
    if(!sameChecksum(cLR0, cLR1)) reportMutation("waveLR");
  }else{
    viz.onFrame(frame);
  }
}
resize();
animate();
</script>
</body>
</html>
